%% Setup

clc;
clear;
close all;

%% Compressive Sensing Parameters

n = 4; % 4096; % number of time values = length of signal
p = 2; % 128; % number of random samples
Fs = 1e8; % 10; % Sampling frequency

T = 1/Fs; % Sampling period
t_values = (0:n-1)*T; % or t_values = (0:n-1)*T ...
f = Fs*(0:n-1)/n; % ... with f = Fs*(0:n-1)/n
w_values = f*pi;

%% System

Number_of_Spatial_Orbitals = 4;
Number_of_Spin_Up_Electrons = 2; % must be >= 2 to compuate a spin-up lesser green's function that is nonzero
Number_of_Spin_Down_Electrons = 2; % must be >= 2 to compute a spin-down lesser green's function that is nonzero
Number of
system = System(Number_of_Spatial_Orbitals,Number_of_Spin_Up_Electrons,Number_of_Spin_Down_Electrons,true,true);

%% Hubbard

U = 1.5;
t_1 = 1.5;
t_0 = 2;
t_2 = 5;
connected_ends = true;

system_minus_up = System(Number_of_Spatial_Orbitals,Number_of_Spin_Up_Electrons-1,Number_of_Spin_Down_Electrons,false,true);
system_minus_down = System(Number_of_Spatial_Orbitals,Number_of_Spin_Up_Electrons,Number_of_Spin_Down_Electrons-1,false,true);

hubbard_model = Hubbard(U,t_1,t_0,t_2,connected_ends,system,system_minus_up,system_minus_down);

%% Lesser Green

spin = "up";
spatial_orbital_index_i = 1;
spatial_orbital_index_j = 2;

lesser_green = LesserGreen(spin,spatial_orbital_index_i,spatial_orbital_index_j,hubbard_model);

[lesser_real,lesser_imaginary] = lesser_green.compute(t_values);

%% Greater Green

greater_green = GreaterGreen(spin,spatial_orbital_index_i,spatial_orbital_index_j,hubbard_model);

[greater_real,greater_imaginary] = greater_green.compute(t_values);

%% Ground State Energy

spins = ["up","down"];
zero_t = 0;
hopping_matrix = hubbard_model.get_hopping_matrix();


ground_state_kinetic = 0;
for spatial_orbital_index_i = 1:Number_of_Spatial_Orbitals
    for spatial_orbital_index_j = 1:Number_of_Spatial_Orbitals
        for spin_index = 1:length(spins)
            spin = spins(spin_index);
            lesser_green = LesserGreen(spin,spatial_orbital_index_j,spatial_orbital_index_i,hubbard_model);
            [lesser_real,lesser_imaginary] = lesser_green.compute(zero_t);
            lesser = lesser_real + (1i) * lesser_imaginary;
            ground_state_kinetic = ground_state_kinetic + (-1i)*hopping_matrix(spatial_orbital_index_i,spatial_orbital_index_j)*lesser;
        end
    end
end


hbar = 1;
t_1 = zero_t;
t_2 = t_values(2);
ground_state_interaction_derivative = 0;
for spatial_orbital_index_j = 1:Number_of_Spatial_Orbitals
    for spin_index = 1:length(spins)
        spin = spins(spin_index);
        lesser_green = LesserGreen(spin,spatial_orbital_index_j,spatial_orbital_index_j,hubbard_model);
        ground_state_interaction_derivative = ground_state_interaction_derivative + (0.5)*(-1)*hbar*lesser_green.numerical_derivative(t_1,t_2);
    end
end


ground_state_interaction_t_jj = 0;
for spatial_orbital_index_j = 1:Number_of_Spatial_Orbitals
    for spin_index = 1:length(spins)
        spin = spins(spin_index);
        lesser_green = LesserGreen(spin,spatial_orbital_index_j,spatial_orbital_index_j,hubbard_model);
        [lesser_real,lesser_imaginary] = lesser_green.compute(zero_t);
        lesser = lesser_real + (1i) * lesser_imaginary;
        ground_state_interaction_t_jj = ground_state_interaction_t_jj + (1i)*(Number_of_Spatial_Orbitals)*(-1)*hopping_matrix(spatial_orbital_index_j,spatial_orbital_index_j)*lesser;
    end
end



ground_state_interaction = ground_state_interaction_derivative + ground_state_interaction_t_jj;
ground_state_energy = ground_state_kinetic + ground_state_interaction - mu*N;

% %% Compressive Sensing
% % Theta*s == y from Steve Brunton is the same as A*x = b from Emmanuel Candes
% 
% % greater
% perm = round(rand(p,1) * n);
% y = -greater_imaginary(perm)'; % compressed measurement
% 
% Psi = dct(eye(n,n)); % build Psi
% Theta = Psi(perm,:); % measure rows of Psi
% 
% % L1-Minimization using CVX
% cvx_begin;
%     variable s(n);
%     minimize( norm(s,1) );
%     subject to
%         Theta*s == y;
% cvx_end;
% 
% % lesser
% y_lesser = lesser_imaginary(perm)'; % compressed measurement
% 
% % L1-Minimization using CVX
% cvx_begin;
%     variable s_lesser(n);
%     minimize( norm(s_lesser,1) );
%     subject to
%         Theta*s_lesser == y_lesser;
% cvx_end;
% 
% %% Plotting
% 
% figure;
% plot(t_values,greater_imaginary,'cyan')
% hold on;
% plot(t_values,greater_real,'red')
% hold on;
% scatter(t_values,lesser_imaginary,'green')
% hold on;
% scatter(t_values,lesser_real,'blue')
% title('Lesser and Greater')
% figure;
% scatter(greater_green.angular_frequency_differences,greater_green.weights,'red');
% hold on;
% scatter(lesser_green.angular_frequency_differences,lesser_green.weights,'red');
% hold on;
% scatter(w_values,s/sum(s),'blue','x');
% hold on;
% scatter(-w_values,s_lesser/abs(sum(s_lesser)),'blue','x')
% title('Lesser and Greater')



